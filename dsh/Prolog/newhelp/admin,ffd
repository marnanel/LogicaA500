/**************************************************
*                   AUI / admin                   *
*                   ***********                   *
*                                                 *
* Program Id     :  admin                         *
* Author         :  Alan Bustany / Simon Dickens  *
* Installation   :  Logica Cambridge Ltd.         *
* Project Name   :  AUI                           *
* Language       :  Quintus PROLOG                *
* Date Written   :  29 / 07 / 87                  *
* Function       :  dialogue manager sends events *
*                   to admin so that the user     *
*                   model is updated              *
* Called by      :  toplevel, dmagb               *
* Modules called :  um                            *
* IPR            :  This software is foreground   *
*                   IPR of Logica UK Ltd. on      *
*                   Adaptive User Interface       *
*                   project (AUI).  Its use is    *
*                   governed by a collaboration   *
*                   agreement dated 31st July 1986*
***************************************************
*              Revision History 1                 *
* Revised by   : S Ala'i                          *
* Date Revised : 21/10/87                         *
* Description  : Porting to PrologX on Acorn ADFS.*
*            R1: 'if' term caused problems with   *
*                memory.  It was written in more  *
*                efficient form using 'functor'   *
*                and 'arg'.                       *
*            R2: 'ad_event_options' broken down   *
*                into separate clauses in order   *
*                eliminate nested (P)->(Q);(R)    *
*                constructs (only six levels of   *
*                nesting allowed).                *
*            R3: redundant terms.                 *
***************************************************
*               Revision History 2                *
* Revised by   : S Ala'i                          *
* Date Revised : 08/12/87                         *
* Description  : Implementation of WP3300 for DISH*
*                All output commands replaced by  *
*                new_output.                      *
***************************************************
*               Revision History 3                *
* Revised by   : S Ala'i                          *
* Date Revised : 08/12/87                         *
* Description  : WP3300 for DISH.                 *
*            R3: new clause to process some_of    *
*                event.                           *
*            R4: new clause to process one_of     *
*                event.                           *
*            R5: changed from step to basic_method*
***************************************************
*               Revision History 4                *
* Revised by   : S Ala'i                          *
* Description  : debugging dish                   *
* 08/03/88   R6: add clause for basic methods     *
*                without objects.                 *
* 14/03/88   R7: event_key modified to prevent    *
*                backtracking for Methods.        *
* 16/03/88   R8: ad_process_event1 modified to    *
*                update the user model entry when *
*                a generic is popped from the     *
*                generic stack.                   *
* 17/03/88   R9: event_key modified to trap       *
*                procedure names.                 *
*           R10: added exit option.               *
* 18/03/88  R11: cut to prevent stack blowing     *
**************************************************/

/*  For each event generated by the Dialogue Manager, update the User Model and 
    output text to the screen (if appropriate)
*/   
 
/*  Updating User Model  */


/*
    Rule 1:

    IF      a step has been executed
    THEN    add 1 to the grade for the current skill level for the step

    Rule 2:

    IF      a procedure has been started
    THEN    add 1 to the grade for the current skill level for the procedure

    Rule 3:

    IF      the user asks 'how', 'where', or 'which'
    THEN    change the skill level of the relevant object/step to recognition or less

    Rule 4:

    IF      the user asks 'why'
    THEN    change the skill level of the relevant step to application or less
*/

/* recursive events are an enormous bodge to allow access to the user model */

/*
*  Name         :  ad_process_events(+Events, +User_Info, +Options,
*                                                              ?User_Model)
*  Function     :  processes the events sent by the dialogue manager in the
*                  top-level loop,
*                  if first event is a recursive event it recurses down
*                  updating the user model at each stage, whereas if it is a
*                  procedure this is carried out in ad_process_event1
*  Arguments    :  Events; list of events received from dialogue manager
*                  User_Info; present user information
*                  Options; chosen options
*                  User_Model; old and new user model represented as a binary
*                  tree
*/
ad_process_events([], _, Options ~ Options,
              User_Model ~ User_Model,
              WimpEnv ~ WimpEnv).
ad_process_events([recursive_event(Context, Option) | Events],
              User_Info,
              Options,
              Old_User_Model ~ New_User_Model,
              WimpEnv):-
   dm(on~on, Option, Context, Old_User_Model, Events1),
   append(Events1, Events, New_Events),
   ad_process_events(New_Events, User_Info, Options,
                 Old_User_Model ~ New_User_Model,
                 WimpEnv).
ad_process_events([event(Procedure, Event) | Events],
              User_Info,
              Old_Options ~ New_Options,
              Old_User_Model ~ New_User_Model,
              OldWimpEnv ~ NewWimpEnv):-
   ad_process_event(Event, Procedure, User_Info,
                Old_User_Model ~ User_Model,
                OldWimpEnv ~ WimpEnv1),
   ad_event_options(Event, Old_Options ~ Options, WimpEnv1 ~ WimpEnv2),
   !,  %R11
   ad_process_events(Events, User_Info,
                 Options ~ New_Options,
                 User_Model ~ New_User_Model,
                 WimpEnv2 ~ NewWimpEnv).

/*
*  Name         :  ad_process_event(+Event, +Procedure, +User_Info,
*                                                              ?User_Model)
*  Function     :  this is called when the event being processed is a
*                  procedure, it carries out the event and updates the user
*                  model offering a warning if this not possible
*  Arguments    :  Event; head of Events list
*                  Procedure; present procedural state
*                  User_Info; present user information
*                  User_Model; old and new user models
*/

ad_process_event(Event, Procedure, User_Info, User_Model, WimpEnv):-
   ad_process_event1(Event, Procedure, User_Info, User_Model, WimpEnv).
ad_process_event(Event, Procedure, User_Info, User_Model, WimpEnv):-
   send_message(".ERROR.4"),
   write('WARNING: no ad_process_event for '), writeln(Event),
   User_Model = UM ~ UM.

/*
*  Name         :  ad_process_event1(+Event, +Procedure, +User_Info,
*                                                               ?User_Model)
*  Function     :  matches the event and updates the user model if necessary
*                  increasing or decreasing knowledge levels
*  Arguments    :  Event; head of Events list
*                  Procedure; present procedural state
*                  User_Info; present user information
*                  User_Model; old and new user models
*/

ad_process_event1(one_of(List),_,_,UserModel ~ UserModel, WimpEnv):-       %R3
   new_output(List,".DLIST",WimpEnv).
ad_process_event1(some_of([Head|Tail]),_,_,UserModel~UserModel, WimpEnv):- %R4
   append(Tail,[Head],List),
   new_output(List,".DLIST",WimpEnv).
ad_process_event1(quit, _, _, UserModel ~ UserModel, WimpEnv ~ WimpEnv).
ad_process_event1(exit, _, _, UserModel ~ UserModel, WimpEnv):-
   new_output(no_text,".EXIT",WimpEnv).
ad_process_event1(toggle(_), _, _, UserModel ~ UserModel, WimpEnv ~ WimpEnv).
ad_process_event1(end_of_timeline, _, _, UserModel ~ UserModel, WimpEnv):-
   new_output(end_of_timeline, ".COM", WimpEnv).
ad_process_event1(help, _, _, UserModel ~ UserModel, WimpEnv ~ WimpEnv).
ad_process_event1(procedure(Procedure), _,_,UserModel ~ UserModel, WimpEnv ~ WimpEnv):-
   output_procedure(Procedure).
ad_process_event1(resume(Procedure), _, _, UserModel ~ UserModel, WimpEnv ~ WimpEnv):-
   pkb_procedure_type(Procedure, Type),
   output(resume(Procedure, Type), proc).
ad_process_event1(remediation, _, user_info(_, User_Type, _), UserModel ~ UserModel, WimpEnv):-
   um_remediation(User_Type, UserModel, Remediation),
   new_output(remediation(Remediation), ".COM", WimpEnv).  
ad_process_event1(Event, Procedure, _, UserModel, WimpEnv ~ NewWimpEnv):-
   event_key(Event, Key),
   um_update_grade(Procedure, Key, UserModel, LastSeen),
   new_output(Event, ".PRO", WimpEnv ~ WimpEnv1),
   new_output(seen_last(Event, LastSeen), ".COM", WimpEnv1 ~ NewWimpEnv).
ad_process_event1(why(Generic, Step), Procedure, _, UserModel, WimpEnv):-
   event_key(Step, Key),
   um_reduce_level(application, Procedure, Key, UserModel),
   new_output(why(Generic, Step), ".COM", WimpEnv).
ad_process_event1(how(Generic), Procedure, _, UserModel, WimpEnv):-
   event_key(Generic, Key),
   um_reduce_level(recognition, Procedure, Key, UserModel),
   new_output(how_intro, ".PRO", WimpEnv).
ad_process_event1(If, _, _, UserModel ~ UserModel, WimpEnv):-
   functor(If,if,5),
   new_output(If, ".PRO", WimpEnv).
ad_process_event1(pop_proc(Proc), _, _, UserModel ~ UserModel, WimpEnv):-
   new_output(end_proc(Proc), ".PRO", WimpEnv).

%R8
ad_process_event1(pop_generic(Generic), Procedure, _, UserModel, WimpEnv ~ WimpEnv):-
   event_key(Generic,Key),
   um_update_grade(Procedure,Key,UserModel,_).

ad_process_event1(push_generic(_), _, _, UserModel ~ UserModel, WimpEnv ~ WimpEnv).
ad_process_event1(stack(Stack_States), _,_, UserModel ~ UserModel, WimpEnv ~ WimpEnv):-
   convert_goal_stack(Stack_States, [Curr_Proc_State | Goal_Stack]),
   output(stack(Curr_Proc_State, Goal_Stack), com).
ad_process_event1(summary(Proc, Done, Doing, ToDo), _, _, UserModel ~ UserModel, WimpEnv):-
   new_output(summary(Proc, Done, Doing, ToDo), ".COM", WimpEnv).

/*
*  Name         :  ad_event_options(+Event, ?Options)
*  Function     :  checks what event is and if necessary makes the new options
*                  a list of the options that become available under that event
*  Arguments    :  Event; present event at the head of the Events list
*                  Options; lists of the old and new options available
*/

ad_event_options(quit, OldOptions~[], WimpEnv ~ WimpEnv).
ad_event_options(exit, OldOptions~OldOptions, WimpEnv~WimpEnv).
ad_event_options(If, OldOptions~NewOptions, WimpEnv ~ WimpEnv):- 
   functor(If,if,5),
   NewOptions = [yes, no, help, summary, stack, remediation, quit, exit].
ad_event_options(basic_method(_), OldOptions~NewOptions, WimpEnv ~ WimpEnv):-
   NewOptions = [help, summary, stack, remediation, quit, exit, why, next].
ad_event_options(generic(_), OldOptions~NewOptions, WimpEnv ~ WimpEnv):- 
   NewOptions = [help, summary, stack, remediation, 
                 quit, exit, why, next, how].
ad_event_options(library(_), OldOptions~NewOptions, WimpEnv ~ WimpEnv):- 
   NewOptions = [help, summary, stack, remediation, 
                 quit, exit, why, next, how].
ad_event_options(help, OldOptions~OldOptions, WimpEnv):-
   new_output(help(OldOptions), ".COM", WimpEnv).
ad_event_options(end_of_timeline, OldOptions~[help, remediation, quit, exit], WimpEnv ~ WimpEnv).
ad_event_options(toggle(_~off), OldOptions~[quit, exit, help], WimpEnv ~ WimpEnv).
ad_event_options(toggle(_~on), OldOptions~[quit, exit, help, next], WimpEnv ~ WimpEnv).
   %  mode_event(Mode, NewOptions).
ad_event_options(Event, OldOptions~OldOptions, WimpEnv ~ WimpEnv).

/*
*  Name         :  mode_event(+Mode, -NewOptions)
*  Function     :  if the dialogue manager has been toggled to off sets the
*                  new available options to a list containing quit and help,
*                  and if it has been toggled to on sets NewOptions to a list
*                  containing quit, help and next
*  Arguments    :  Mode; old and new dialogue manager status e.g. off~on
*                  NewOptions; new available list of options
*/

mode_event(_~off, [quit, help]).
mode_event(_~on, [quit, help, next]).

/*
*  Name         :  event_key(+Event, -Key)
*  Function     :  obtains a key to the present event (a node in the user
*                  model)
*  Arguments    :  Event; present event
*                  Key; a key to the present event in the form type(call-name)
*                  e.g.  either object(Obj), step(Step), generic(Step),
*                  library(Step), conclusion(Step) or procedure(Procedure)
*/

event_key(basic_method(Method:Object), basic_method(Method)).   %R5
event_key(basic_method(Method), basic_method(Method)):-         %R6
   \+ functor(Method,:,_).                                      %R7
event_key(generic('use dish'), procedure('use dish')).          %R9
event_key(generic(Generic), generic(Functor)):-
   \+ Generic = 'use dish',                                     %R9
   functor(Generic, Functor, _).
event_key(conclusion(Conc), conclusion(Functor)):-
   \+ functor(Conc, null_conclusion, _),                        %R7
   functor(Conc, Functor, _).
event_key(library(Method:Object), library(Method)).
event_key(library(GenericStep), library(Functor)):-
   \+ functor(GenericStep,:,_),                                 %R7
   functor(GenericStep, Functor, _).
event_key(push_proc(Procedure), procedure(Functor)):- functor(Procedure, Functor, _).

/*
*  Name         :  ad_objects_exist(+Key, -Options)
*  Function     :  if key represents a recognised Object then sets the list of
*                  options to [where] else to the empty list
*  Arguments    :  Key; key to the present event
*                  Options; list of options available for that event
*/

ad_objects_exist(Key, Options) :-
    objects(Key, _) ->
            Options = [where]
    ;
            Options = [].

/* PREDICATES STARTING WITH convert NOT NEEDED FOR NEW_OUTPUT */

%/*
%*  Name         :  convert_steps(+Old_List, -New_List)
%*  Function     :  takes two lists of steps and recursively converts
%*                  corresponding elements using The_Biz_Bodge (the converted
%*                  part of the key)
%*  Arguments    :  Old_List; old list of steps
%*               :  New_List; new list of steps
%*/
%
%convert_steps([], []).
%convert_steps([Step|Steps], [Step1|Steps1]) :-
%    convert_step1(Step, Step1),
%    convert_steps(Steps, Steps1).
%
%/*
%*  Name         :  convert_step1(+Step, -Step1)
%*  Function     :  if Step is an 'if' clause this converts the list of
%*                  conclusions Then and Else to the new conclusions Then1 and
%*                  Else1, otherwise calls convert_step on Step
%*  Arguments    :  Step; head of list of Steps to be converted
%*                  Step1; head of converted list
%*/
%
%convert_step1(if(Cond, P_Conc, Then, N_Conc, Else), if(Cond, P_Conc, Then1, N_Conc, Else1)) :-
%    convert_steps(Then, Then1),
%    convert_steps(Else, Else1).
%convert_step1(Step, Step1) :-
%    \+ functor(Step,if,5),                                        %R1
%    convert_step(Step, Step1).
%
%/*
%*  Name         :  convert_step(+Step, ?The_Biz_Bodge)
%*  Function     :  takes Step and converts it
%*  Arguments    :  Step; step to be converted
%*                  The_Biz_Bodge; this is what is placed in the part of Step
%*                  to be converted
%*/
%
%convert_step(Step, The_Biz_Bodge) :-
%      Step = step(The_Biz_Bodge) ->
%            true
%    ; Step = generic(The_Biz_Bodge) ->
%            true
%    ; functor(Step,if,5) ->                                          %R1
%            arg(1,Step,The_Biz_Bodge)                                %R1
%    ; Step = library(Generic_Step) ->
%            The_Biz_Bodge = generic_step(Generic_Step)
%    ; Step = push_proc(Proc) ->
%            The_Biz_Bodge = procedure(Proc)
%    ; otherwise ->
%            The_Biz_Bodge = Step . 
%
%/*
%*  Name         :  convert_why_step(+Step, +Procedure, -New_Step)
%*  Function     :  converts a why step to New_Step unless Step is generic(root)
%*                  in which case sets New_Step to the present procedural state
%*  Arguments    :  Step; present step
%*                  Procedure; present procedural state
%*                  New_Step; the converted why step
%*/
%
%convert_why_step(generic(root), Procedure, Procedure).
%convert_why_step(Step, _, New_Step) :-
%    Step ~= generic(root),
%    convert_step(Step, New_Step).
%
%/*
%*  Name         :  convert_goal_stack(+Goal_States, -New_Goal_States)
%*  Function     :  (called when processing a stack event) if the arguments are
%*                  not empty then recurses down the stack of goal states
%*                  converting each step in each state
%*  Arguments    :  Goal_States; present list of stacked goals
%*                  New_Goal_States; converted list of stacked goals
%*/
%
%convert_goal_stack([], []).
%convert_goal_stack([Goal_State|Goal_States], [New_Goal_State|New_Goal_States]) :-
%    convert_proc_state(Goal_State, New_Goal_State),
%    convert_goal_stack(Goal_States, New_Goal_States).
%
%/*
%*  Name         :  convert_proc_state(+Goal_State, -New_Goal_State)
%*  Function     :  does the hard work in the above predicate by converting each
%*                  step within the stacked state passed to it
%*  Arguments    :  Goal_State; stacked state structure
%*                  New_Goal_State; stacked state containing converted steps
%*/
%
%convert_proc_state(stack_state(Proc, Type, Step), stack_state(Proc, Type, New_Step)) :-
%    convert_step(Step, New_Step).

/*
*  Name         :  output_procedure(+Procedure)
*  Function     :  pretty prints the procedure and prints out the steps text
*  Arguments    :  Procedure; present procedure being processed
*/

output_procedure(Procedure) :-
    pp_proc(0, step, Procedure, Steps_Text),
    send_to_area(proc, Steps_Text).
